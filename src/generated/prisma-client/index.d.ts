// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  floor: (where?: FloorWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  wall: (where?: WallWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  floor: (where: FloorWhereUniqueInput) => FloorNullablePromise;
  floors: (args?: {
    where?: FloorWhereInput;
    orderBy?: FloorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Floor>;
  floorsConnection: (args?: {
    where?: FloorWhereInput;
    orderBy?: FloorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FloorConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  wall: (where: WallWhereUniqueInput) => WallNullablePromise;
  walls: (args?: {
    where?: WallWhereInput;
    orderBy?: WallOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Wall>;
  wallsConnection: (args?: {
    where?: WallWhereInput;
    orderBy?: WallOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WallConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createFloor: (data: FloorCreateInput) => FloorPromise;
  updateFloor: (args: {
    data: FloorUpdateInput;
    where: FloorWhereUniqueInput;
  }) => FloorPromise;
  updateManyFloors: (args: {
    data: FloorUpdateManyMutationInput;
    where?: FloorWhereInput;
  }) => BatchPayloadPromise;
  upsertFloor: (args: {
    where: FloorWhereUniqueInput;
    create: FloorCreateInput;
    update: FloorUpdateInput;
  }) => FloorPromise;
  deleteFloor: (where: FloorWhereUniqueInput) => FloorPromise;
  deleteManyFloors: (where?: FloorWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createWall: (data: WallCreateInput) => WallPromise;
  updateWall: (args: {
    data: WallUpdateInput;
    where: WallWhereUniqueInput;
  }) => WallPromise;
  updateManyWalls: (args: {
    data: WallUpdateManyMutationInput;
    where?: WallWhereInput;
  }) => BatchPayloadPromise;
  upsertWall: (args: {
    where: WallWhereUniqueInput;
    create: WallCreateInput;
    update: WallUpdateInput;
  }) => WallPromise;
  deleteWall: (where: WallWhereUniqueInput) => WallPromise;
  deleteManyWalls: (where?: WallWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  floor: (
    where?: FloorSubscriptionWhereInput
  ) => FloorSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  wall: (
    where?: WallSubscriptionWhereInput
  ) => WallSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type WallOrderByInput = "id_ASC" | "id_DESC" | "name_ASC" | "name_DESC";

export type FloorOrderByInput = "id_ASC" | "id_DESC" | "name_ASC" | "name_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type FloorWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface WallWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  AND?: Maybe<WallWhereInput[] | WallWhereInput>;
  OR?: Maybe<WallWhereInput[] | WallWhereInput>;
  NOT?: Maybe<WallWhereInput[] | WallWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  walls_every?: Maybe<WallWhereInput>;
  walls_some?: Maybe<WallWhereInput>;
  walls_none?: Maybe<WallWhereInput>;
  floors_every?: Maybe<FloorWhereInput>;
  floors_some?: Maybe<FloorWhereInput>;
  floors_none?: Maybe<FloorWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface FloorWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  AND?: Maybe<FloorWhereInput[] | FloorWhereInput>;
  OR?: Maybe<FloorWhereInput[] | FloorWhereInput>;
  NOT?: Maybe<FloorWhereInput[] | FloorWhereInput>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export type WallWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface FloorCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  createdBy?: Maybe<UserCreateOneWithoutFloorsInput>;
}

export interface UserCreateOneWithoutFloorsInput {
  create?: Maybe<UserCreateWithoutFloorsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutFloorsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  walls?: Maybe<WallCreateManyWithoutCreatedByInput>;
}

export interface WallCreateManyWithoutCreatedByInput {
  create?: Maybe<
    WallCreateWithoutCreatedByInput[] | WallCreateWithoutCreatedByInput
  >;
  connect?: Maybe<WallWhereUniqueInput[] | WallWhereUniqueInput>;
}

export interface WallCreateWithoutCreatedByInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface FloorUpdateInput {
  name?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneWithoutFloorsInput>;
}

export interface UserUpdateOneWithoutFloorsInput {
  create?: Maybe<UserCreateWithoutFloorsInput>;
  update?: Maybe<UserUpdateWithoutFloorsDataInput>;
  upsert?: Maybe<UserUpsertWithoutFloorsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutFloorsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  walls?: Maybe<WallUpdateManyWithoutCreatedByInput>;
}

export interface WallUpdateManyWithoutCreatedByInput {
  create?: Maybe<
    WallCreateWithoutCreatedByInput[] | WallCreateWithoutCreatedByInput
  >;
  delete?: Maybe<WallWhereUniqueInput[] | WallWhereUniqueInput>;
  connect?: Maybe<WallWhereUniqueInput[] | WallWhereUniqueInput>;
  set?: Maybe<WallWhereUniqueInput[] | WallWhereUniqueInput>;
  disconnect?: Maybe<WallWhereUniqueInput[] | WallWhereUniqueInput>;
  update?: Maybe<
    | WallUpdateWithWhereUniqueWithoutCreatedByInput[]
    | WallUpdateWithWhereUniqueWithoutCreatedByInput
  >;
  upsert?: Maybe<
    | WallUpsertWithWhereUniqueWithoutCreatedByInput[]
    | WallUpsertWithWhereUniqueWithoutCreatedByInput
  >;
  deleteMany?: Maybe<WallScalarWhereInput[] | WallScalarWhereInput>;
  updateMany?: Maybe<
    WallUpdateManyWithWhereNestedInput[] | WallUpdateManyWithWhereNestedInput
  >;
}

export interface WallUpdateWithWhereUniqueWithoutCreatedByInput {
  where: WallWhereUniqueInput;
  data: WallUpdateWithoutCreatedByDataInput;
}

export interface WallUpdateWithoutCreatedByDataInput {
  name?: Maybe<String>;
}

export interface WallUpsertWithWhereUniqueWithoutCreatedByInput {
  where: WallWhereUniqueInput;
  update: WallUpdateWithoutCreatedByDataInput;
  create: WallCreateWithoutCreatedByInput;
}

export interface WallScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<WallScalarWhereInput[] | WallScalarWhereInput>;
  OR?: Maybe<WallScalarWhereInput[] | WallScalarWhereInput>;
  NOT?: Maybe<WallScalarWhereInput[] | WallScalarWhereInput>;
}

export interface WallUpdateManyWithWhereNestedInput {
  where: WallScalarWhereInput;
  data: WallUpdateManyDataInput;
}

export interface WallUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface UserUpsertWithoutFloorsInput {
  update: UserUpdateWithoutFloorsDataInput;
  create: UserCreateWithoutFloorsInput;
}

export interface FloorUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  walls?: Maybe<WallCreateManyWithoutCreatedByInput>;
  floors?: Maybe<FloorCreateManyWithoutCreatedByInput>;
}

export interface FloorCreateManyWithoutCreatedByInput {
  create?: Maybe<
    FloorCreateWithoutCreatedByInput[] | FloorCreateWithoutCreatedByInput
  >;
  connect?: Maybe<FloorWhereUniqueInput[] | FloorWhereUniqueInput>;
}

export interface FloorCreateWithoutCreatedByInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface UserUpdateInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  walls?: Maybe<WallUpdateManyWithoutCreatedByInput>;
  floors?: Maybe<FloorUpdateManyWithoutCreatedByInput>;
}

export interface FloorUpdateManyWithoutCreatedByInput {
  create?: Maybe<
    FloorCreateWithoutCreatedByInput[] | FloorCreateWithoutCreatedByInput
  >;
  delete?: Maybe<FloorWhereUniqueInput[] | FloorWhereUniqueInput>;
  connect?: Maybe<FloorWhereUniqueInput[] | FloorWhereUniqueInput>;
  set?: Maybe<FloorWhereUniqueInput[] | FloorWhereUniqueInput>;
  disconnect?: Maybe<FloorWhereUniqueInput[] | FloorWhereUniqueInput>;
  update?: Maybe<
    | FloorUpdateWithWhereUniqueWithoutCreatedByInput[]
    | FloorUpdateWithWhereUniqueWithoutCreatedByInput
  >;
  upsert?: Maybe<
    | FloorUpsertWithWhereUniqueWithoutCreatedByInput[]
    | FloorUpsertWithWhereUniqueWithoutCreatedByInput
  >;
  deleteMany?: Maybe<FloorScalarWhereInput[] | FloorScalarWhereInput>;
  updateMany?: Maybe<
    FloorUpdateManyWithWhereNestedInput[] | FloorUpdateManyWithWhereNestedInput
  >;
}

export interface FloorUpdateWithWhereUniqueWithoutCreatedByInput {
  where: FloorWhereUniqueInput;
  data: FloorUpdateWithoutCreatedByDataInput;
}

export interface FloorUpdateWithoutCreatedByDataInput {
  name?: Maybe<String>;
}

export interface FloorUpsertWithWhereUniqueWithoutCreatedByInput {
  where: FloorWhereUniqueInput;
  update: FloorUpdateWithoutCreatedByDataInput;
  create: FloorCreateWithoutCreatedByInput;
}

export interface FloorScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<FloorScalarWhereInput[] | FloorScalarWhereInput>;
  OR?: Maybe<FloorScalarWhereInput[] | FloorScalarWhereInput>;
  NOT?: Maybe<FloorScalarWhereInput[] | FloorScalarWhereInput>;
}

export interface FloorUpdateManyWithWhereNestedInput {
  where: FloorScalarWhereInput;
  data: FloorUpdateManyDataInput;
}

export interface FloorUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface UserUpdateManyMutationInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
}

export interface WallCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  createdBy?: Maybe<UserCreateOneWithoutWallsInput>;
}

export interface UserCreateOneWithoutWallsInput {
  create?: Maybe<UserCreateWithoutWallsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutWallsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  floors?: Maybe<FloorCreateManyWithoutCreatedByInput>;
}

export interface WallUpdateInput {
  name?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneWithoutWallsInput>;
}

export interface UserUpdateOneWithoutWallsInput {
  create?: Maybe<UserCreateWithoutWallsInput>;
  update?: Maybe<UserUpdateWithoutWallsDataInput>;
  upsert?: Maybe<UserUpsertWithoutWallsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutWallsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  floors?: Maybe<FloorUpdateManyWithoutCreatedByInput>;
}

export interface UserUpsertWithoutWallsInput {
  update: UserUpdateWithoutWallsDataInput;
  create: UserCreateWithoutWallsInput;
}

export interface WallUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface FloorSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FloorWhereInput>;
  AND?: Maybe<FloorSubscriptionWhereInput[] | FloorSubscriptionWhereInput>;
  OR?: Maybe<FloorSubscriptionWhereInput[] | FloorSubscriptionWhereInput>;
  NOT?: Maybe<FloorSubscriptionWhereInput[] | FloorSubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface WallSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<WallWhereInput>;
  AND?: Maybe<WallSubscriptionWhereInput[] | WallSubscriptionWhereInput>;
  OR?: Maybe<WallSubscriptionWhereInput[] | WallSubscriptionWhereInput>;
  NOT?: Maybe<WallSubscriptionWhereInput[] | WallSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Floor {
  id: ID_Output;
  name: String;
}

export interface FloorPromise extends Promise<Floor>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
}

export interface FloorSubscription
  extends Promise<AsyncIterator<Floor>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
}

export interface FloorNullablePromise
  extends Promise<Floor | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
}

export interface User {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  walls: <T = FragmentableArray<Wall>>(args?: {
    where?: WallWhereInput;
    orderBy?: WallOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  floors: <T = FragmentableArray<Floor>>(args?: {
    where?: FloorWhereInput;
    orderBy?: FloorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  walls: <T = Promise<AsyncIterator<WallSubscription>>>(args?: {
    where?: WallWhereInput;
    orderBy?: WallOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  floors: <T = Promise<AsyncIterator<FloorSubscription>>>(args?: {
    where?: FloorWhereInput;
    orderBy?: FloorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  walls: <T = FragmentableArray<Wall>>(args?: {
    where?: WallWhereInput;
    orderBy?: WallOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  floors: <T = FragmentableArray<Floor>>(args?: {
    where?: FloorWhereInput;
    orderBy?: FloorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Wall {
  id: ID_Output;
  name: String;
}

export interface WallPromise extends Promise<Wall>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
}

export interface WallSubscription
  extends Promise<AsyncIterator<Wall>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
}

export interface WallNullablePromise
  extends Promise<Wall | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
}

export interface FloorConnection {
  pageInfo: PageInfo;
  edges: FloorEdge[];
}

export interface FloorConnectionPromise
  extends Promise<FloorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FloorEdge>>() => T;
  aggregate: <T = AggregateFloorPromise>() => T;
}

export interface FloorConnectionSubscription
  extends Promise<AsyncIterator<FloorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FloorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFloorSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface FloorEdge {
  node: Floor;
  cursor: String;
}

export interface FloorEdgePromise extends Promise<FloorEdge>, Fragmentable {
  node: <T = FloorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FloorEdgeSubscription
  extends Promise<AsyncIterator<FloorEdge>>,
    Fragmentable {
  node: <T = FloorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFloor {
  count: Int;
}

export interface AggregateFloorPromise
  extends Promise<AggregateFloor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFloorSubscription
  extends Promise<AsyncIterator<AggregateFloor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WallConnection {
  pageInfo: PageInfo;
  edges: WallEdge[];
}

export interface WallConnectionPromise
  extends Promise<WallConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WallEdge>>() => T;
  aggregate: <T = AggregateWallPromise>() => T;
}

export interface WallConnectionSubscription
  extends Promise<AsyncIterator<WallConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WallEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWallSubscription>() => T;
}

export interface WallEdge {
  node: Wall;
  cursor: String;
}

export interface WallEdgePromise extends Promise<WallEdge>, Fragmentable {
  node: <T = WallPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WallEdgeSubscription
  extends Promise<AsyncIterator<WallEdge>>,
    Fragmentable {
  node: <T = WallSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWall {
  count: Int;
}

export interface AggregateWallPromise
  extends Promise<AggregateWall>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWallSubscription
  extends Promise<AsyncIterator<AggregateWall>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface FloorSubscriptionPayload {
  mutation: MutationType;
  node: Floor;
  updatedFields: String[];
  previousValues: FloorPreviousValues;
}

export interface FloorSubscriptionPayloadPromise
  extends Promise<FloorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FloorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FloorPreviousValuesPromise>() => T;
}

export interface FloorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FloorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FloorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FloorPreviousValuesSubscription>() => T;
}

export interface FloorPreviousValues {
  id: ID_Output;
  name: String;
}

export interface FloorPreviousValuesPromise
  extends Promise<FloorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface FloorPreviousValuesSubscription
  extends Promise<AsyncIterator<FloorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface WallSubscriptionPayload {
  mutation: MutationType;
  node: Wall;
  updatedFields: String[];
  previousValues: WallPreviousValues;
}

export interface WallSubscriptionPayloadPromise
  extends Promise<WallSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WallPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WallPreviousValuesPromise>() => T;
}

export interface WallSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WallSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WallSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WallPreviousValuesSubscription>() => T;
}

export interface WallPreviousValues {
  id: ID_Output;
  name: String;
}

export interface WallPreviousValuesPromise
  extends Promise<WallPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface WallPreviousValuesSubscription
  extends Promise<AsyncIterator<WallPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Wall",
    embedded: false
  },
  {
    name: "Floor",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
